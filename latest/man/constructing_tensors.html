<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Constructing tensors · ContMechTensors.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script></head><body><nav class="toc"><h1>ContMechTensors.jl</h1><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li class="current"><a class="toctext" href="constructing_tensors.html">Constructing tensors</a><ul class="internal"><li><a class="toctext" href="#Zero-tensors-1">Zero tensors</a></li><li><a class="toctext" href="#Constant-tensors-1">Constant tensors</a></li><li><a class="toctext" href="#Random-tensors-1">Random tensors</a></li><li><a class="toctext" href="#Identity-tensors-1">Identity tensors</a></li><li><a class="toctext" href="#From-arrays-/-tuples-1">From arrays / tuples</a></li><li><a class="toctext" href="#function_index-1">From a function</a></li><li><a class="toctext" href="#Diagonal-tensors-1">Diagonal tensors</a></li><li><a class="toctext" href="#Converting-to-tensors-1">Converting to tensors</a></li></ul></li><li><a class="toctext" href="indexing.html">Indexing</a></li><li><a class="toctext" href="binary_operators.html">Binary Operations</a></li><li><a class="toctext" href="other_operators.html">Other operators</a></li><li><a class="toctext" href="storing_tensors.html">Storing tensors</a></li></ul></li><li><a class="toctext" href="../demos.html">Demos</a></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="constructing_tensors.html">Constructing tensors</a></li></ul><a class="edit-page" href="https://github.com/KristofferC/ContMechTensors.jl/tree/5b56b0042c7a2f023122ee6da0cb565bee8e135f/docs/src/man/constructing_tensors.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Constructing-tensors-1" href="#Constructing-tensors-1">Constructing tensors</a></h1><p>Tensors can be created in multiple ways but they usually include running a function on tensor types of which there are two kinds, <code>Tensor{order, dim, T}</code> for non-symmetric tensors and <code>SymmetricTensor{order, dim, T}</code> for symmetric tensors. The parameter <code>order</code> is an integer of value 1, 2 or 4, excluding 1 for symmetric tensors. The second parameter <code>dim</code> is an integer which corresponds to the dimension of the tensor and can be 1, 2 or 3. The last parameter <code>T</code> is the number type that the tensors contain, i.e. <code>Float64</code> or <code>Float32</code>.</p><h2><a class="nav-anchor" id="Zero-tensors-1" href="#Zero-tensors-1">Zero tensors</a></h2><p>A tensor with only zeros is created using the function <code>zero</code>, applied to the type of tensor that should be created:</p><pre><code class="language-jlcon">julia&gt; zero(Tensor{1, 2})
2-element ContMechTensors.Tensor{1,2,Float64,2}:
 0.0
 0.0</code></pre><p>By default, a tensor of <code>Float64</code>s is created but by explicitly giving the <code>T</code> parameter, this can be changed:</p><pre><code class="language-jlcon">julia&gt; zero(SymmetricTensor{4, 2, Float32})
2×2×2×2 ContMechTensors.SymmetricTensor{4,2,Float32,9}:
[:, :, 1, 1] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 1] =
 0.0  0.0
 0.0  0.0

[:, :, 1, 2] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 2] =
 0.0  0.0
 0.0  0.0</code></pre><h2><a class="nav-anchor" id="Constant-tensors-1" href="#Constant-tensors-1">Constant tensors</a></h2><p>A tensor filled with ones is created using the function <code>ones</code>, applied to the type of tensor that should be created:</p><pre><code class="language-jlcon">julia&gt; ones(Tensor{2,2})
2×2 ContMechTensors.Tensor{2,2,Float64,4}:
 1.0  1.0
 1.0  1.0</code></pre><p>By default, a tensor of <code>Float64</code>s is created but by explicitly giving the <code>T</code> parameter, this can be changed:</p><pre><code class="language-jlcon">julia&gt; ones(Vec{3,Float32})
3-element ContMechTensors.Tensor{1,3,Float32,3}:
 1.0
 1.0
 1.0</code></pre><h2><a class="nav-anchor" id="Random-tensors-1" href="#Random-tensors-1">Random tensors</a></h2><p>A tensor with random numbers is created using the function <code>rand</code>, applied to the type of tensor that should be created:</p><pre><code class="language-jlcon">julia&gt; rand(Tensor{2, 3})
3×3 ContMechTensors.Tensor{2,3,Float64,9}:
 0.590845  0.460085  0.200586
 0.766797  0.794026  0.298614
 0.566237  0.854147  0.246837</code></pre><p>By specifying the type, <code>T</code>, a tensor of different type can be obtained:</p><pre><code class="language-jlcon">julia&gt; rand(SymmetricTensor{2,3,Float32})
3×3 ContMechTensors.SymmetricTensor{2,3,Float32,6}:
 0.0107703  0.305865  0.2082
 0.305865   0.405684  0.257278
 0.2082     0.257278  0.958491</code></pre><h2><a class="nav-anchor" id="Identity-tensors-1" href="#Identity-tensors-1">Identity tensors</a></h2><p>An identity tensor is created using the function <code>one</code>, applied to the type of tensor that should be created:</p><pre><code class="language-jlcon">julia&gt; one(SymmetricTensor{2, 2})
2×2 ContMechTensors.SymmetricTensor{2,2,Float64,3}:
 1.0  0.0
 0.0  1.0</code></pre><p>The identity tensor is only defined for tensors of order 2 and 4.</p><h2><a class="nav-anchor" id="From-arrays-/-tuples-1" href="#From-arrays-/-tuples-1">From arrays / tuples</a></h2><p>Tensors can also be created from a tuple or an array with the same number of elements as the number of independent indices in the tensor. For example, a first order tensor (vector) in two dimensions is here created from a vector of length two:</p><pre><code class="language-jlcon">julia&gt; Tensor{1,2}([1.0,2.0])
2-element ContMechTensors.Tensor{1,2,Float64,2}:
 1.0
 2.0</code></pre><p>Below, a second order symmetric tensor in two dimensions is created from a tuple. Since the number of independent indices in this tensor is three, the length of the tuple is also three. For symmetric tensors, the order of the numbers in the input tuple is column by column, starting at the diagonal.</p><pre><code class="language-jlcon">julia&gt; SymmetricTensor{2,2}((1.0,2.0,3.0))
2×2 ContMechTensors.SymmetricTensor{2,2,Float64,3}:
 1.0  2.0
 2.0  3.0</code></pre><h2><a class="nav-anchor" id="function_index-1" href="#function_index-1">From a function</a></h2><p>A tensor can be created from a function <code>f(indices...) -&gt; v</code> which maps a set of indices to a value. The number of arguments of the function should be equal to the order of the tensor.</p><pre><code class="language-jlcon">julia&gt; SymmetricTensor{2,2,Float64}((i,j) -&gt; i + j)
2×2 ContMechTensors.SymmetricTensor{2,2,Float64,3}:
 2.0  3.0
 3.0  4.0</code></pre><p>For symmetric tensors, the function is only called for the lower triangular part.</p><h2><a class="nav-anchor" id="Diagonal-tensors-1" href="#Diagonal-tensors-1">Diagonal tensors</a></h2><p>A diagonal tensor can be created by either giving a number or a vector that should appear on the diagonal:</p><pre><code class="language-jlcon">julia&gt; diagm(Tensor{2,2}, 2.0)
2×2 ContMechTensors.Tensor{2,2,Float64,4}:
 2.0  0.0
 0.0  2.0

julia&gt; diagm(SymmetricTensor{2,3}, [1.0, 2.0, 3.0])
3×3 ContMechTensors.SymmetricTensor{2,3,Float64,6}:
 1.0  0.0  0.0
 0.0  2.0  0.0
 0.0  0.0  3.0</code></pre><h2><a class="nav-anchor" id="Converting-to-tensors-1" href="#Converting-to-tensors-1">Converting to tensors</a></h2><p>Sometimes it is necessary to convert between standard Julia <code>Array</code>&#39;s and <code>Tensor</code>&#39;s. When the number type is a bits type (like for floats or integers) this is conveniently done by the <code>reinterpret</code> function. For example, a <code>2×5</code> Julia <code>Array</code> can be translated to a vector of <code>Vec{2}</code> with the following code</p><pre><code class="language-jlcon">julia&gt; data = rand(2, 5)
2×5 Array{Float64,2}:
 0.590845  0.566237  0.794026  0.200586  0.246837
 0.766797  0.460085  0.854147  0.298614  0.579672

julia&gt; tensor_data = reinterpret(Vec{2, Float64}, data, (5,))
5-element Array{ContMechTensors.Tensor{1,2,Float64,2},1}:
 [0.590845,0.766797]
 [0.566237,0.460085]
 [0.794026,0.854147]
 [0.200586,0.298614]
 [0.246837,0.579672]</code></pre><p>The data can also be reinterpreted back to a Julia <code>Array</code></p><pre><code class="language-jlcon">julia&gt; data = reinterpret(Float64, tensor_data, (2,5))
2×5 Array{Float64,2}:
 0.590845  0.566237  0.794026  0.200586  0.246837
 0.766797  0.460085  0.854147  0.298614  0.579672</code></pre><footer><hr/><a class="previous" href="../index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="indexing.html"><span class="direction">Next</span><span class="title">Indexing</span></a></footer></article></body></html>
